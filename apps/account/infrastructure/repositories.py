from apps.account.domain.aggregates.user_account import UserAccount
from apps.account.domain.value_objects.email import Email
from apps.account.domain.value_objects.nickname import NickName
from apps.account.domain.value_objects.social_link import SocialLink
from apps.account.domain.repositories import UserAccountRepository
from apps.account.models import Users, UserSocialAccounts

from typing import Optional
from django.db import transaction


class DjangoUserAccountRepository(UserAccountRepository):

    def generate_next_id(self) -> int:
        raise NotImplementedError("ID is auto-generated by the database.")

    def _to_domain_object(self, user_model: Users) -> UserAccount:
        social_links_vo_list = []
        if user_model and hasattr(user_model, 'social_accounts'):  # Check if user_model is not None
            for link_model in user_model.social_accounts.all():
                social_links_vo_list.append(
                    SocialLink(provider_name=link_model.provider, social_id=link_model.provider_account_id)
                )

        return UserAccount(
            account_id=user_model.id,
            email=Email(user_model.email_address),
            nickname=NickName(user_model.nickname),
            social_links=social_links_vo_list,
            created_at=user_model.created_at,
            last_login_at=user_model.last_login_at
        )

    @transaction.atomic
    def save(self, user_account: UserAccount) -> UserAccount:
        if user_account.account_id and user_account.account_id > 0:
            try:
                user_model = Users.objects.get(id=user_account.account_id)
                user_model.email_address = user_account.email.address
                user_model.nickname = user_account.nickname.name
                user_model.last_login_at = user_account.last_login_at
                user_model.save(update_fields=['email_address', 'nickname', 'last_login_at'])
            except Users.DoesNotExist:
                raise ValueError(f"ID {user_account.account_id}를 가진 사용자가 존재하지 않아 업데이트할 수 없습니다.")
        else:
            user_model = Users.objects.create(
                email_address=user_account.email.address,
                nickname=user_account.nickname.name,
                created_at=user_account.created_at,
                last_login_at=user_account.last_login_at
            )

        UserSocialAccounts.objects.filter(user=user_model).delete()
        for sl_vo_item in user_account.social_links:
            UserSocialAccounts.objects.create(
                user=user_model,
                provider=sl_vo_item.provider_name,
                provider_account_id=sl_vo_item.social_id
            )

        return self._to_domain_object(user_model)

    @transaction.atomic
    def delete(self, account_id: int) -> None:
        try:
            user_model = Users.objects.get(id=account_id)
            user_model.delete()
        except Users.DoesNotExist:
            pass

    def find_by_id(self, account_id: int) -> Optional[UserAccount]:
        try:
            user_model = Users.objects.get(id=account_id)
            return self._to_domain_object(user_model)
        except Users.DoesNotExist:
            return None

    def find_by_email(self, email: Email) -> Optional[UserAccount]:
        try:
            user_model = Users.objects.get(email_address=email.address)
            return self._to_domain_object(user_model)
        except Users.DoesNotExist:
            return None

    def find_by_nickname(self, nickname: NickName) -> Optional[UserAccount]:
        try:
            user_model = Users.objects.get(nickname=nickname.name)
            return self._to_domain_object(user_model)
        except Users.DoesNotExist:
            return None
    def find_by_social_link(self, social_link: SocialLink) -> Optional[UserAccount]:
        try:
            link_model = UserSocialAccounts.objects.select_related('user').get(
                provider=social_link.provider_name,
                provider_account_id=social_link.social_id
            )
            if link_model.user:
                return self._to_domain_object(link_model.user)
            return None
        except UserSocialAccounts.DoesNotExist:
            return None
        except Users.DoesNotExist:
            return None
